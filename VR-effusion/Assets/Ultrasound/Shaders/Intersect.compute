// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Main
#pragma kernel Init
#pragma kernel Raster

#define SIZEOF_FLOAT 4
#define SIZEOF_FLOAT3 12
#define SIZEOF_INDEX 4

uint MAX_VERTICES_OUT;
uint WIDTH, HEIGHT;

struct Material {
    float density;
    float stiffness;
    float roughness;
};

ByteAddressBuffer _inVertices;
ByteAddressBuffer _inIndices;

uint _inOffset = 0;
uint _inCount;
uint _inStride;

Material _inMaterial;

uint3 readTriangle(uint i) {
    return _inIndices.Load3((i * 3 + _inOffset) * SIZEOF_INDEX);
}

float3 readVertex(uint i) {
    float3 r = asfloat(_inVertices.Load3(i * _inStride));
    return r;
}
RWStructuredBuffer<uint> _counter;
RWByteAddressBuffer _outVertices;
RWTexture2D<float4> _outBuffer;
uint _outStride;

void writeVertex(uint i, float3 v) {
    _outVertices.Store3(i * _outStride, asuint(v));
}


float4x4 matrix_view;
float4x4 matrix_model;
float4x4 u_inverse;
float3 u_plane;
float u_offset;

float3 clip(float3 f) {
    float3 a = abs(f);
    float m = max(max(a.x, a.y), a.z);
    if (m > 1.0)
        f /= m;
    return f;
}

//bool onScreen(float3 a, float3 b, float3 c) {
//    return any(min(min(a, b), c) <= 1.0) && any(max(max(a, b), c) >= -1.0);
//}

[numthreads(64,1,1)]
void Main(uint3 id : SV_DispatchThreadID) {
    if (id.x * 3 >= _inCount)
        return;

    uint3 i = readTriangle(id.x);

    float3 p0 = readVertex(i.x);
    float3 p1 = readVertex(i.y);
    float3 p2 = readVertex(i.z);

    float4x4 modelView = mul(matrix_view, matrix_model);

    float3 v0 = mul(modelView, float4(p0, 1.0)).xyz;
    float3 v1 = mul(modelView, float4(p1, 1.0)).xyz;
    float3 v2 = mul(modelView, float4(p2, 1.0)).xyz;

    //if (!onScreen(v0, v1, v2))
    //    return;

    float d0 = dot(v0, u_plane) - u_offset;
    float d1 = dot(v1, u_plane) - u_offset;
    float d2 = dot(v2, u_plane) - u_offset;

    float l01 = -(d0) / dot(v1 - v0, u_plane);
    float l12 = -(d1) / dot(v2 - v1, u_plane);
    float l20 = -(d2) / dot(v0 - v2, u_plane);

    bool i0 = (0.0 < l01 && l01 < 1.0);
    bool i1 = (0.0 < l12 && l12 < 1.0);
    bool i2 = (0.0 < l20 && l20 < 1.0);

    float3 w0 = 0.0, w1 = 0.0;

    if (i0 && i1) {
        w0 = lerp(v0, v1, l01);
        w1 = lerp(v1, v2, l12);
    } else if (i1 && i2) {
        w0 = lerp(v1, v2, l12);
        w1 = lerp(v2, v0, l20);
    } else if (i2 && i0) {
        w0 = lerp(v2, v0, l20);
        w1 = lerp(v0, v1, l01);
    } else if (abs(d0) + abs(d1) <= 0.001) {
        w0 = v0;
        w1 = v1;
    } else if (abs(d1) + abs(d2) <= 0.001) {
        w0 = v1;
        w1 = v2;
    } else if (abs(d2) + abs(d0) <= 0.001) {
        w0 = v2;
        w1 = v0;
    } else {
        return;
    }

    uint c = 2 * _counter.IncrementCounter();
    if (c >= MAX_VERTICES_OUT)
        return;

    writeVertex(c + 0, w0);
    writeVertex(c + 1, w1);
}

const float3 null = float3(0.0, 0.0, 0.0);

[numthreads(64, 1, 1)]
void Init(uint3 id : SV_DispatchThreadID) {
    while(true) {
        uint c = 2 * _counter.IncrementCounter();
        if (c >= MAX_VERTICES_OUT)
            break;

        writeVertex(c + 0, null);
        writeVertex(c + 1, null);
    }
}

[numthreads(64, 1, 1)]
void Raster(uint3 id : SV_DispatchThreadID) {
    uint c = 2 * id.x;
    if (c > MAX_VERTICES_OUT)
        return;

    int2 v0 = int2((asfloat(_outVertices.Load3((c + 0) * SIZEOF_FLOAT3)).xz * float2(0.5, -0.5) + 0.5) * float2(WIDTH, HEIGHT));
    int2 v1 = int2((asfloat(_outVertices.Load3((c + 1) * SIZEOF_FLOAT3)).xz * float2(0.5, -0.5) + 0.5) * float2(WIDTH, HEIGHT));

    _outBuffer[v0] = float4(1.0, 0.0, 0.0, 1.0);
    _outBuffer[v1] = float4(1.0, 0.0, 0.0, 1.0);

    if (v1.x < v0.x) {
        int2 t = v0;
        v0 = v1;
        v1  = t;
    }

    int dx = v1.x - v0.x;
    int dy = v1.y - v0.y;


    for (int x = v0.x; x <= v1.x; x++) {
        int y = v0.y + (x - v0.x) * dy / dx;

        _outBuffer[int2(x, y)] = float4(1.0, 1.0, 1.0, 1.0);
    }


}
